package io.github.opencubicchunks.cubicchunks.world.level.cube;

import io.github.notstirred.dasm.api.annotations.redirect.redirects.AddMethodToSets;
import io.github.notstirred.dasm.api.annotations.selector.MethodSig;
import io.github.notstirred.dasm.api.annotations.selector.Ref;
import io.github.notstirred.dasm.api.annotations.transform.TransformFromClass;
import io.github.opencubicchunks.cubicchunks.mixin.CubeAccessAndDescendantsSet;
import io.github.opencubicchunks.cubicchunks.world.level.chunklike.ImposterProtoClo;
import io.github.opencubicchunks.cubicchunks.world.level.chunklike.LevelClo;
import net.minecraft.world.level.chunk.ImposterProtoChunk;

// Whole class redirect
@TransformFromClass(value = @Ref(ImposterProtoChunk.class), sets = CubeAccessAndDescendantsSet.class)
public class ImposterProtoCube extends ProtoCube implements ImposterProtoClo {
    // Field cleared and re-generated by DASM; we just need it here because otherwise mixin does not detect that the field exists.
    private LevelCube wrapped;

    public ImposterProtoCube(LevelCube wrapped, boolean allowWrites) {
        super(null, null, null, null, null);
        throw new IllegalStateException("DASM failed to apply");
    }

    // Method is implemented in MixinImposterProtoCube instead, since DASM clears everything in this class.
    @AddMethodToSets(sets = CubeAccessAndDescendantsSet.class, owner = @Ref(ImposterProtoChunk.class), method = @MethodSig("Lnet/minecraft/world/level/chunk/ImposterProtoChunk;getWrapped()Lnet/minecraft/world/level/chunk/LevelChunk;"))
    @Override public LevelClo cc_getWrappedClo() {
        throw new IllegalStateException("DASM failed to apply");
    }
}
